<! DOCTYPE html>
<html lang="es">
  <cabeza>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <t√≠tulo>AR con Texto Animado</title>
    <estilo>
      * {
        margen: 0;
        Relleno: 0;
        tama√±o de caja: border-box;
      }

      cuerpo {
        Antecedentes: #1a1a2e;
        Pantalla: Flex;
        justify-content: centro;
        alinear-elementos: centro;
        Altura m√≠nima: 100 Vh;
        familia de fuentes: Arial, sans-serif;
      }

      .contenedor {
        Posici√≥n: relativa;
        Ancho: 90%;
        ancho m√°ximo: 600px;
      }

      lona {
        Ancho: 100%;
        Radio del borde: 10px;
        Sombra de caja: 0 0 30px rgba(0, 255, 255, 0.5);
        Pantalla: Bloque;
        Antecedentes: #000;
      }

      #info {
        Posici√≥n: Absoluta;
        Arriba: 15px;
        Izquierda: 15px;
        Antecedentes: RGBA(0, 0, 0, 0.8);
        Color: #00ffff;
        Relleno: 15px;
        radio del borde: 8px;
        borde: 2px #00ffff s√≥lido ;
        tama√±o de fuente: 13px;
        √çndice Z: 10;
        ancho m√°ximo: 250px;
      }

      #info h3 {
        margen inferior: 8px;
        sombra de texto: 0 0 5px #00ffff;
      }

      .estado {
        margen: 5px 0;
        tama√±o de fuente: 12px;
      }

      .status.detected {
        Color: #00ff00;
      }

      .status.not-detected {
        Color: #ff4444;
      }

      #controls {
        Posici√≥n: Absoluta;
        Abajo: 15px;
        Izquierda: 50%;
        transform: translateX(-50%);
        Antecedentes: RGBA(0, 0, 0, 0.8);
        Relleno: 12px 20px;
        radio del borde: 8px;
        borde: 2px #00ffff s√≥lido ;
        √çndice Z: 10;
      }

      bot√≥n {
        Fondo: gradiente lineal (135 grados, #00ffff, #00ccff);
        Borde: Ninguno;
        Relleno: 10px 20px;
        margen: 0 5px;
        radio del borde: 5px;
        cursor: puntero;
        peso de fuente: negrita;
        Color: #000;
        Transici√≥n: todos 0.3s;
        tama√±o de fuente: 12px;
      }

      bot√≥n: hover {
        transformar: escala(1.05);
      }

      .slider-contenedor {
        Posici√≥n: Absoluta;
        Arriba: 15px;
        Derecha: 15px;
        Antecedentes: RGBA(0, 0, 0, 0.8);
        Relleno: 12px;
        radio del borde: 8px;
        borde: 2px #00ffff s√≥lido ;
        √çndice Z: 10;
      }

      .slider-container  {
        Color: #00ffff;
        Pantalla: Bloque;
        tama√±o de fuente: 12px;
        margen inferior: 5px;
      }

      input[type="rango"] {
        Ancho: 120px;
      }
    </estilo>
  </cabeza>
  <cuerpo>
    <div class="contenedor">
      <canvas id="canvas"></canvas>

      <div id="info">
        <h3>AR + Texto Animado</h3>
        <div class="status" id="statusDetection"> üîç Escaneando... </div>
        <div style="margin-top: 10px; tama√±o de fuente: 11px; Color: #ccc">
 √Årea detectada: <span id="areaValue">0</span>%
        </div>
      </div>

      <div class="contenedor-deslizante">
        <etiqueta>Sensibilidad:</label>
        <input type="range" id="sensitivity" min="10" max="100" value="50" />
      </div>

      <div id="controles">
        <button onclick="toggleMode()"> üîÑ Modo</button>
        <button onclick="togglePause()"> ‚è∏ Pausar</button>
        <button onclick="toggleText()"> üìù Texto</button>
      </div>
    </div>

    <video id="video" style="display: none"></video>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const video = document.getElementById("video");

      canvas.width = 600;
      canvas.height = 450;

      let time = 0;
      let paused = false;
      let mode = 0;
      let showText = true;

      const animatedTexts = [
        {
          text: "üåå REALIDAD AUMENTADA",
          y: 50,
          fontSize: 24,
          color: "#00ffff",
          animation: "float",
        },
        {
          text: "Detecci√≥n de Espacios",
          y: 420,
          fontSize: 18,
          color: "#ff00ff",
          animation: "typewriter",
        },
        {
          text: "Holograma Activo",
          x: 10,
          y: 350,
          fontSize: 14,
          color: "#00ff00",
          animation: "pulse",
        },
      ];

      async function startCamera() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "environment" },
          });
          video.srcObject = stream;
          video.onloadedmetadata = () => {
            video.play();
            mainLoop();
          };
        } catch (error) {
          alert("Error: " + error.message);
        }
      }

      function detectEmptySpace() {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        let emptyPixels = 0;
        let totalPixels = data.length / 4;

        for (let i = 0; i < data.length; i += 4) {
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          const brightness = (r + g + b) / 3;

          let isEmpty = false;
          if (mode === 0) {
            isEmpty = brightness < 100;
          } else {
            isEmpty = brightness > 150;
          }

          if (isEmpty) emptyPixels++;
        }

        const percentage = (emptyPixels / totalPixels) * 100;
        return percentage;
      }

      function findBestPosition() {
        const zoneWidth = canvas.width / 3;
        const zoneHeight = canvas.height / 3;

        let bestZone = null;
        let maxEmptyPixels = 0;

        for (let row = 0; row < 3; row++) {
          for (let col = 0; col < 3; col++) {
            const x = col * zoneWidth;
            const y = row * zoneHeight;

            const imageData = ctx.getImageData(x, y, zoneWidth, zoneHeight);
            const data = imageData.data;

            let emptyCount = 0;
            for (let i = 0; i < data.length; i += 4) {
              const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
              let isEmpty = mode === 0 ? brightness < 100 : brightness > 150;
              if (isEmpty) emptyCount++;
            }

            if (emptyCount > maxEmptyPixels) {
              maxEmptyPixels = emptyCount;
              bestZone = {
                x: x + zoneWidth / 2,
                y: y + zoneHeight / 2,
                col,
                row,
              };
            }
          }
        }

        return bestZone;
      }

      function drawHologramAtPosition(position) {
        if (!position) return;

        const { x, y } = position;
        const size = 40;

        const pulse = Math.sin(time * 0.05) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(0, 255, 255, ${0.2 * pulse})`;
        ctx.beginPath();
        ctx.arc(x, y, size * 1.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "rgb(0, 255, 255)";
        ctx.lineWidth = 2;
        for (let i = 1; i <= 2; i++) {
          ctx.beginPath();
          ctx.arc(x, y, size * i * 0.4, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(time * 0.03);
        ctx.fillStyle = "rgba(0, 255, 255, 0.8)";
        ctx.beginPath();
        const points = [
          [0, -size],
          [size, 0],
          [0, size],
          [-size, 0],
        ];
        ctx.moveTo(points[0][0], points[0][1]);
        points.forEach((p) => ctx.lineTo(p[0], p[1]));
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        ctx.strokeStyle = "rgba(0, 255, 255, 0.3)";
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(x - size * 2, y - size * 2, size * 4, size * 4);
        ctx.setLineDash([]);
      }

      function drawFloatingText(text, y, fontSize, color) {
        const offset = Math.sin(time * 0.02) * 10;

        ctx.fillStyle = color;
        ctx.font = `bold ${fontSize}px Arial`;
        ctx.textAlign = "center";
        ctx.shadowColor = color;
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        ctx.fillText(text, canvas.width / 2, y + offset);

        ctx.shadowBlur = 0;
      }

      function drawTypewriterText(text, y, fontSize, color) {
        const cycleTime = 2000; // Ciclo de 2 segundos
        const timeInCycle = (time * 16) % cycleTime; // 16ms por frame
        const charsToShow = Math.floor((timeInCycle / cycleTime) * text.length);
        const displayText = text.substring(0, charsToShow);

        ctx.fillStyle = color;
        ctx.font = `bold ${fontSize}px Arial`;
        ctx.textAlign = "center";
        ctx.shadowColor = color;
        ctx.shadowBlur = 8;

        ctx.fillText(displayText, canvas.width / 2, y);

        if (time % 20 < 10) {
          ctx.fillText(
            "|",
            canvas.width / 2 + displayText.length * (fontSize * 0.6),
            y
          );
        }

        ctx.shadowBlur = 0;
      }

      function drawPulseText(text, x, y, fontSize, color) {
        const pulse = Math.sin(time * 0.08) * 0.5 + 0.5; // 0 a 1
        const alpha = (pulse * 0.7 + 0.3).toFixed(2); // 0.3 a 1.0

        ctx.fillStyle = color;
        ctx.globalAlpha = alpha;
        ctx.font = `bold ${fontSize}px Arial`;
        ctx.textAlign = "left";
        ctx.shadowColor = color;
        ctx.shadowBlur = 15;

        ctx.fillText(text, x, y);

        ctx.globalAlpha = 1.0;
        ctx.shadowBlur = 0;
      }

      function drawAnimatedTexts() {
        if (!showText) return;

        animatedTexts.forEach((textObj) => {
          switch (textObj.animation) {
            case "float":
              drawFloatingText(
                textObj.text,
                textObj.y,
                textObj.fontSize,
                textObj.color
              );
              break;
            case "typewriter":
              drawTypewriterText(
                textObj.text,
                textObj.y,
                textObj.fontSize,
                textObj.color
              );
              break;
            case "pulse":
              drawPulseText(
                textObj.text,
                textObj.x,
                textObj.y,
                textObj.fontSize,
                textObj.color
              );
              break;
            default:
              drawFloatingText(
                textObj.text,
                textObj.y,
                textObj.fontSize,
                textObj.color
              );
          }
        });
      }

      function mainLoop() {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const emptyPercentage = detectEmptySpace();
        const bestPosition = findBestPosition();

        if (bestPosition) {
          drawHologramAtPosition(bestPosition);
        }

        drawAnimatedTexts();

        document.getElementById("areaValue").textContent =
          emptyPercentage.toFixed(1);

        const statusEl = document.getElementById("statusDetection");
        if (emptyPercentage > 30) {
          statusEl.className = "status detected";
          statusEl.textContent = "Espacio detectado";
        } else {
          statusEl.className = "status not-detected";
          statusEl.textContent = " Buscando espacio...";
        }

        if (!paused) time++;

        requestAnimationFrame(mainLoop);
      }

      function toggleMode() {
 modo = (modo + 1) % 2;
        const modeNames = ["Oscuro (piso/sombra)", "Brillante (pared)"];
        console.log("Modo:", modeNames[mode]);
      }

      function togglePause() {
 pausado = !pausado;
 document.querySelector("button:nth-child(2)").textContent = pausado
          ? "‚ñ∂ Reanudar"
          : "‚è∏ Pausar";
      }

      function toggleText() {
 mostrarTexto = !mostrarTexto;
        document.querySelector("button:nth-child(3)").textContent = showText
 ? " üìù Texto"
 : " üìù Apagado";
      }

      document.getElementById("sensitivity").addEventListener("input", (e) => {
 console.log("Sensibilidad:", e.target.value); 
      });

      startCamera();
    </script>
  </cuerpo>
</html>
