<! DOCTYPE html>
<html lang="es">
<cabeza>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detecci√≥n de Espacios Vac√≠os</title>
<estilo>
        * {
margen: 0;
relleno: 0;
tama√±o de caja: border-box;
        }
        
cuerpo {
Antecedentes: #1a1a2e;
pantalla: flex;
justify-content: centro;
alinear-elementos: centro;
Altura m√≠nima: 100 Vh;
familia de fuentes: Arial, sans-serif;
        }
        
.contenedor {
posici√≥n: relativa;
ancho: 90%;
ancho m√°ximo: 600px;
        }
        
lienzo {
ancho: 100%;
radio del borde: 10px;
sombra de caja: 0 0 30px rgba(0, 255, 255, 0.5);
display: bloque;
antecedentes: #000;
        }
        
        #info {
posici√≥n: absoluta;
arriba: 15px;
izquierda: 15px;
Antecedentes: RGBA(0, 0, 0, 0.8);
            color: #00ffff;
relleno: 15px;
radio del borde: 8px;
borde: 2px #00ffff s√≥lido;
tama√±o de fuente: 13px;
√≠ndice z: 10;
ancho m√°ximo: 250px;
        }
        
        #info h3 {
margen inferior: 8px;
            text-shadow: 0 0 5px #00ffff;
        }
        
.estado {
margen: 5px 0;
tama√±o de fuente: 12px;
        }
        
        .status.detected {
            color: #00ff00;
        }
        
.status.no-detectado {
            color: #ff4444;
        }
        
        #controls {
posici√≥n: absoluta;
abajo: 15px;
izquierda: 50%;
transformar: translateX(-50%);
Antecedentes: RGBA(0, 0, 0, 0.8);
relleno: 12px 20px;
radio del borde: 8px;
borde: 2px #00ffff s√≥lido;
√≠ndice z: 10;
        }
        
bot√≥n {
fondo: gradiente lineal (135 grados, #00ffff, #00ccff);
borde: ninguno;
relleno: 10px 20px;
margen: 0 5px;
radio del borde: 5px;
cursor: puntero;
peso de fuente: negrita;
            color: #000;
transici√≥n: todos 0.3s;
tama√±o de fuente: 12px;
        }
        
bot√≥n:hover {
transformar: escala (1.05);
        }
        
.slider-contenedor {
posici√≥n: absoluta;
arriba: 15px;
derecha: 15px;
Antecedentes: RGBA(0, 0, 0, 0.8);
relleno: 12px;
radio del borde: 8px;
borde: 2px #00ffff s√≥lido;
√≠ndice z: 10;
        }
        
.slider-container etiqueta {
            color: #00ffff;
display: bloque;
tama√±o de fuente: 12px;
margen inferior: 5px;
        }
        
        input[type="range"] {
ancho: 120px;
        }
</estilo>
</cabeza>
<cuerpo>
<div class="contenedor">
        <canvas id="canvas"></canvas>
        
        <div id="info">
<h3> üéØ Detecci√≥n</h3>
<div class="status" id="statusDetection"> üîç Escaneando... </div>
<div style="margin-top: 10px; tama√±o de fuente: 11px; color: #ccc;" >
                √Årea detectada: <span id="areaValue">0</span>%
            </div>
        </div>
        
        <div class="slider-container">
            <label>Sensibilidad:</label>
<input type="range" id="sensibilidad" min="10" max="100" value="50">
        </div>
        
<div id="controles">
<button onclick="toggleMode()"> üîÑ Modo</button>
<button onclick="togglePause()"> ‚è∏ Pausar</button>
        </div>
    </div>

<video id="video" style="display: none;" ></video>

<gui√≥n>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('video');
        
Configuraci√≥n adaptable
        canvas.width = 600;
        canvas.height = 450;
        
sea tiempo = 0;
        let paused = false;
modo let = 0; 0: oscuro, 1: brillante
        
===== PASO 1: INICIAR C√ÅMARA =====
funci√≥n as√≠ncrona startCamera() {
prueba {
                const stream = await navigator.mediaDevices.getUserMedia({
video: { facingMode: 'entorno' }
                });
video.srcObject = flujo;
                video.onloadedmetadata = () => {
                    video.play();
                    mainLoop();
                };
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }
        
===== PASO 2: DETECTAR ESPACIOS VAC√çOS =====
        function detectEmptySpace() {
Obtener datos de p√≠xeles del canvas
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let emptyPixels = 0;
let totalPixels = data.length / 4; 4 valores por p√≠xel (RGBA)
            
Recorrer cada p√≠xel
for (sea i = 0; i < data.length; i += 4) {
const r = datos[i];
const g = datos[i + 1];
const b = datos[i + 2];
                
Calcular brillo del p√≠xel
brillo constante = (r + g + b) / 3;
                
                let isEmpty = false;
                
if (modo === 0) {
Modo: detectar √°reas OSCURAS (piso, sombras)
isEmpty = brillo < 100;
                } else {
Modo: detectar √°reas CLARAS (paredes blancas)
isEmpty = brillo > 150;
                }
                
                if (isEmpty) {
                    emptyPixels++;
                }
            }
            
Calcular porcentaje
const porcentaje = (emptyPixels / totalPixels) * 100;
porcentaje de devoluci√≥n;
        }
        
===== PASO 3: ENCONTRAR POSICI√ìN PARA OBJETO =====
        function findBestPosition() {
Analizar diferentes zonas del canvas
            const zoneWidth = canvas.width / 3;
            const zoneHeight = canvas.height / 3;
            
            let bestZone = null;
sea maxEmptyPixels = 0;
            
Dividir en 9 zonas (3x3)
for (let fila = 0; fila < 3; fila++) {
                for (let col = 0; col < 3; col++) {
                    const x = col * zoneWidth;
const y = fila * zoneHeight;
                    
Contar p√≠xeles vac√≠os en esta zona
                    const imageData = ctx.getImageData(x, y, zoneWidth, zoneHeight);
                    const data = imageData.data;
                    
                    let emptyCount = 0;
for (sea i = 0; i < data.length; i += 4) {
brillo constante = (datos [i] + datos [i + 1] + datos [i + 2]) / 3;
let isEmpty = mode === 0 ? brillo < 100 : brillo > 150;
                        if (isEmpty) emptyCount++;
                    }
                    
                    if (emptyCount > maxEmptyPixels) {
                        maxEmptyPixels = emptyCount;
mejorZona = {
                            x: x + zoneWidth / 2,
                            y: y + zoneHeight / 2,
col, fila
                        };
                    }
                }
            }
            
devuelve bestZone;
        }
        
===== PASO 4: DIBUJAR HOLOGRAMA EN POSICI√ìN DETECTADA =====
function drawHologramAtPosition(posici√≥n) {
            if (!position) return;
            
const { x, y } = posici√≥n;
tama√±o constante = 40;
            
Aura
pulso const = Math.sin(tiempo * 0,05) * 0,5 + 0,5;
ctx.fillStyle = 'rgba(0, 255, 255, ${0.2 * pulse})';
            ctx.beginPath();
ctx.arc(x, y, tama√±o * 1.5, 0, Math.PI * 2);
            ctx.fill();
            
Anillos
            ctx.strokeStyle = 'rgb(0, 255, 255)';
            ctx.lineWidth = 2;
for (sea i = 1; i <= 2; i++) {
                ctx.beginPath();
ctx.arc(x, y, tama√±o * i * 0.4, 0, Math.PI * 2);
                ctx.stroke();
            }
            
N√∫cleo girando
            ctx.save();
            ctx.translate(x, y);
ctx.rotate(tiempo * 0.03);
            ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
            ctx.beginPath();
puntos const = [[0, -size], [size, 0], [0, size], [-size, 0]];
ctx.moveTo(puntos[0][0], puntos[0][1]);
puntos.forEach(p => ctx.lineTo(p[0], p[1]));
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
Indicador de zona
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
ctx.strokeRect(x - tama√±o * 2, y - tama√±o * 2, tama√±o * 4, tama√±o * 4);
            ctx.setLineDash([]);
        }
        
===== PASO 5: BUCLE PRINCIPAL =====
        function mainLoop() {
Dibujar video
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
Superposici√≥n oscuro
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
Detectar espacios vac√≠os
            const emptyPercentage = detectEmptySpace();
            
Encontrar mejor posici√≥n
            const bestPosition = findBestPosition();
            
Dibujar holograma en posici√≥n detectada
if (mejorPosici√≥n) {
                drawHologramAtPosition(bestPosition);
            }
            
Actualizar informaci√≥n
            document.getElementById('areaValue').textContent = 
                emptyPercentage.toFixed(1);
            
            const statusEl = document.getElementById('statusDetection');
if (PorcentajeVac√≠o > 30) {
statusEl.className = 'estado detectado';
statusEl.textContent = ' ‚úÖ Espacio detectado';
            } else {
statusEl.className = 'estado no detectado';
statusEl.textContent = ' ‚ùå Buscando espacio...';
            }
            
Actualizar tiempo
            if (!paused) time++;
            
            requestAnimationFrame(mainLoop);
        }
        
===== CONTROLES =====
        function toggleMode() {
modo = (modo + 1) % 2;
            const modeNames = ['Oscuro (piso/sombra)', 'Brillante (pared)'];
            console.log('Modo:', modeNames[mode]);
        }
        
        function togglePause() {
pausado = !pausado;
            document.querySelector('button:nth-child(2)').textContent = 
¬øPausa? ' ‚ñ∂ Reanudar' : ' ‚è∏ Pausar';
        }
        
document.getElementById('sensibilidad').addEventListener('entrada', (e) => {
Este slider puede usarse para ajustar el umbral de detecci√≥n
            console.log('Sensibilidad:', e.target.value);
        });
        
===== INICIAR =====
        startCamera();
    </script>
</cuerpo>
</html>
